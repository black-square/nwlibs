#ifndef AsyncIOConnection_HPP
#define AsyncIOConnection_HPP

#include <limits>

///////////////////////////////////////////////////////////////////////////////
// Файл содержит описание интерфейсов классов для асинхронного ввода/вывода
///////////////////////////////////////////////////////////////////////////////

namespace NWLib
{
///////////////////////////////////////////////////////////////////////////////   
// Универсальный интерфейс стратегий конкретного поведения клиента и сервера, 
// которые поддерживают логическое соединение и асинхронный ввод/вывод.
// Для каждого соединения создаётся класс производный от TConnectionBasic.
// Все соединения разделяют между собой класс производный от TGlobalDataBasic
// который создаётся один раз и который может быть использован на усмотрение 
// пользователя
///////////////////////////////////////////////////////////////////////////////
namespace AsyncIOConnection
{
   //Значение таймера обозначющее бесконечность
   inline DWORD TimerInfinityVal() { return std::numeric_limits<DWORD>::max(); }

   ///////////////////////////////////////////////////////////////////////////////
   // Класс от которого наследуется TConnectionBasic. Служит для перенаправления 
   // вызовов внутренним методам класса Сервера/Клиента.
   // Пользователь в классе производном от TConnectionBasic должен вызывать методы
   // данного класса для отправки и принятия данных, а также для управления соединением
   ///////////////////////////////////////////////////////////////////////////////
   template< class FuncImplT >
   struct TCallRedirection
   {
      //Тип класса используемого для стратегии разделяемой между соединениями памяти
      typedef typename FuncImplT::TConnection TConnection;
      typedef typename FuncImplT::TUserGlobalData TUserGlobalData;

   public:
      //Поставить в очередь запрос на чтение
      //pBuf - Буфер в который следует читать
      //Len -  Размер данных для чтения
      //Об окончании чтения порции данных класс производный от TConnectionBasic будет уведомлён при помощи вызова
      //метода OnReceive. Если во входном потоке был обнаружен конец файла(закытие соединения) класс производный 
      //от TConnectionBasic будет уведомлён при помощи вызов метода OnEndReceive
      void TryReceive( char *pBuf, int Length )
      {
         static_cast<TConnection *>(this)->TryReceive( pBuf, Length );
      }

      //Поставить в очередь запрос на запись
      //pBuf - Буфер который следует записать
      //Len -  Размер данных для записи
      //Об окончании записи порции данных класс производный от TConnectionBasic будет уведомлён при помощи вызова
      //метода OnSend. Если во входном потоке был обнаружен конец файла(закытие соединения) класс производный 
      //от TConnectionBasic будет уведомлён при помощи вызов метода OnEndSend
      void TrySend( const char *pBuf, int Length )
      {
         static_cast<TConnection *>(this)->TrySend( pBuf, Length );
      }

      //Поставить в очередь запрос на разрыв соединения.
      //О разрыве соединения класс производный от TConnectionBasic будет уведомлён при помощи вызова
      //метода OnDisconnect.
      void TryDisconnect()
      {
         static_cast<TConnection *>(this)->TryDisconnect();
      }
      
      //Находится ли соединение в состоянии отключения.
      //Т.е. пользователь вызвал метод TryDisconnect и вызов методов TrySend и TryReceive не
      //приведёт к передаче или получению данных
      bool IsDisconnecting() 
      {
         return static_cast<TConnection *>(this)->IsDisconnecting();
      }

      //Получить ссылку на производный от TGlobalDataBasic классс который передан в параметре шаблона 
      //GlobalDataT класса Сервера/Клиента
      TUserGlobalData &GetGlobalData() { return static_cast<TConnection *>(this)->GetGlobalData(); }
      const TUserGlobalData &GetGlobalData() const { return static_cast<const TConnection *>(this)->GetGlobalData(); }

      //Установить время ожидания чтения/записи таймера в миллисекундах.
      //Эквивалентно параметру TSettings::DefaultIOWaitTime
      //Можно воспользоваться значением TimerInfinityVal() для бесконечного ожидания
      void SetIOTimer( DWORD dwMilliseconds )
      {
         static_cast<TConnection *>(this)->SetIOTimer(dwMilliseconds);
      }
      
      //Установить время в миллисекундах ожидания Передачи данных перед закрытием соединения.
      //Эквивалентно параметру TSettings::DefaultCloseWaitTime
      void SetCloseTimer( DWORD dwMilliseconds )
      {
         static_cast<TConnection *>(this)->SetCloseTimer(dwMilliseconds);
      }

      //Перестать принимать новые соединения. После этого сервер ждёт завершения всех
      //созданных к данному моменту соединений, при этом не передаётся флаг досрочного закрытия соединений.
      //GlobalData можно использовать как счётчик соединенний
      //Для того чтобы текущее соединение стало последним надо в конструкторе класса наследника от
      //TConnectionBasic вызвать данную функцию (Если вызывать в методе OnConnection или ещё где либо, 
      //возможно создание нескольких новых соединений из-за многопоточности)
      void StopWaitConnection()
      {
         static_cast<TConnection *>(this)->StopWaitConnection();
      }

      //Сообщить противоположной стороне то что данные отправляться больше не будут.
      //Аналог конца файла. Противоположная сторона будет уведомлена вызовом метода OnEndReceive.
      //Данную функцию желательно вызывать для "Аккуратного размыкания" graceful соединения.
      void EndSend()
      {
         static_cast<TConnection *>(this)->EndSend();
      }
   };

   ///////////////////////////////////////////////////////////////////////////////
   // Базовый класс для стратегии разделяемой области памяти между всеми соединениями.
   // Класс Сервер/Клиент открыто наследует переданный в параметре шаблона GlobalDataT - класс
   // который должен являться наследником TGlobalDataBasic и затем передаёт ссылку на 
   // этот класс классу соединения. 
   // Производный класс может заместить любой метод TGlobalDataBasic.
   // TTCPBasicClientServer не выполняет какую либо синхронизацию при доступе к GlobalDataT
   // пользователь сам должен заботится об этом.
   // Можно создать класс, который будет наследоваться от класса Сервера/Клиента, а в 
   // производном от TGlobalDataBasic приводить указатель this на такой класс.
   ///////////////////////////////////////////////////////////////////////////////
   class TGlobalDataBasic
   {
   public:   
      //Конструктор по умолчанию вызывается конструктором класса Сервера/Клиента без параметров
      TGlobalDataBasic() {}

      //В конструктор можно передать любой необходимой пользователю параметр по средством вызова
      //шаблонного конструктора класса Сервера/Клиента
      //Переопределяемый конструктор может не быть шаблонным если типы известны.
      template <class InitDataT>
      TGlobalDataBasic(const InitDataT &InitData) {}

      //Деструктор вызовется в деструкторе класса Сервера/Клиента
      ~TGlobalDataBasic() {}
   };

   ///////////////////////////////////////////////////////////////////////////////
   // Базовый класс соединения.
   // Класс Сервера/Клиента создаёт при поступлении нового соединения класс производный 
   // от TConnectionBasic и переданный в параметре ConnectionT.
   // Производный класс должен быть шаблоном перенаправляющем свой параметр классу
   // TConnectionBasic (никаким другим образом параметр шаблона не используется в 
   // производных классах)
   // При закрытии соединения класс уничтожатся.
   // Класс реализует стратегию асинхронного ввода/вывода, т.е. вызывая методы Try..
   // класса TCallRedirection, пользователь лишь добавляет задачу, об окончании 
   // которой он будет уведомлён вызовом соответствующего замещённого в 
   // производном от TConnectionBasic On... метода
   // Необходимо учитывать то что все методы OnSend, OnReceive, OnTimer могут вызываться одновременно 
   // в разных потоках (поэтому необходимо заботится о синхронизации). В то же время КОРРЕКТНА ситуация
   // при которой в методе OnReceive один поток собирается вернуть false (но функция ещё не вернула 
   // управление), в то время как другой поток в методе OnSend вызывает метод TryReceive (То же самое 
   // по аналогии с методами OnSend и TrySend). 
   //     (Примечание: Это корректно сейчас т.к. все методы вызываются в одном потоке и будет корректно
   //     в дальнейшем при переходе на Overlapped Socket I/O
   //     т.к. The WSARecv function can be called from within the completion routine of a previous 
   //     WSARecv, WSARecvFrom, WSASend or WSASendTo function. For a given socket, 
   //     I/O completion routines will not be nested. This permits time-sensitive data transmissions 
   //     to occur entirely within a preemptive context.)
   //
   // ВНИМАНИЕ: Если нет задания на чтение или запись данных соединение разрывается.
   ///////////////////////////////////////////////////////////////////////////////
   template< class FuncImplT >
   class TConnectionBasic: public TCallRedirection<FuncImplT>
   {
   public:
      //Код завершения операции
      //Возможно в последствии добавятся коды ошибок
      enum TEndResult
      {
         EROk,             //Удачное завершение
         ERUnknownError    //Завершение с неопознанной ошибкой
      };

   protected:
      //Конструктор по умолчанию никогда не будет вызван, переопредилять его не имеет смысл
      TConnectionBasic() {}

   public:
      //Конструктор вызывается при создании подключения
      //Пользоваться методом GetGlobalData уже можно
      //При создании соединения в конструктор можно передать любой необходимой пользователю 
      //параметр по средством вызова Run у сервера и Connect у клиента с параметром InitData. 
      //Переопределяемый конструктор может не быть шаблонным если тип InitDataT извесен.
      //Если нет необходимости передавать параметр в конструктор то можно в качестве параметра 
      //InitDataT метода Run у сервера и Connect у клиента передать например NullType
      template <class InitDataT>
      TConnectionBasic(const InitDataT &InitData) {}
      
      //Уведомление в том что закончилась операция записи
      //Количество записаных байт может быть меньше того которое
      //было указано в параметре Length метода TrySend, такую ситуацию 
      //надо корректно обрабатывать (попытаться записать повторно неотправленные данные).
      //pBuf   - Ссылка на указатель на буффер для следующей операции записи
      //Length - Ссылка на размер данных для следующей операции записи
      //SendSize - Количество отправленных байт (0, Length] 
      //Возвр  - true:  Необходимо выполнить очередную операцию записи c параметрами pBuf и Length, 
      //                после окончания которой будет вновь вызван OnSend
      //         false: Необходимо закончить запись 
      //Параметры pBuf и Length во время передачи в функцию указывают на переданные в методе 
      //TrySend (OnSend) параметры, необходимо их скорректировать для следующей операции записи, 
      //если планируется её производить (необходимо вернуть true).
      bool OnSend( int SendSize, const char *&pBuf, int &Length )
      {
         return false;
      }

      //Уведомление в том что закончилась операция чтения
      //Количество прочитанных байт может быть меньше того которое
      //было указано в параметре Length метода TryReceive, такую ситуацию 
      //надо корректно обрабатывать (попытаться прочитать повторно если это необходимо).
      //pBuf   - Ссылка на указатель на буффер для следующей операции чтения
      //Length - Ссылка на размер данных для следующей операции чтения
      //ReceiveSize - Количество принятых байт (0, Length] 
      //Возвр  - true:  Необходимо выполнить очередную операцию чтения c параметрами pBuf и Length, 
      //                после окончания которой будет вновь вызван OnReceive
      //         false: Необходимо закончить чтение 
      //Параметры pBuf и Length во время передачи в функцию указывают на переданные в методе 
      //TryReceive (OnReceive) параметры, необходимо их скорректировать для следующей операции чтения, 
      //если планируется её производить (необходимо вернуть true).
      bool OnReceive( int ReceiveSize, char *&pBuf, int &Length )
      {
         return false;
      }

      //Уведомление в том что соединение установлено
      //Необходимо выполнить запрос на чтение или/и запись (TrySend и/или TryReceive) в противном 
      //случае соединение будет разорвано
      void OnConnect() {}

      //Уведомление в том что соединение разорвано.
      //Соединение может быть разоврано в любой момент. Гарантируется что после разрыва соединения
      //не будут приходить какие либо уведомления
      void OnDisconnect() {}

      //Уведомление в том что чтение закончилось (признак EOF)
      //ER - Код завершения
      //Разрыв соединения и вызов OnDisconnect может пройти и без вызова OnEndReceive
      void OnEndReceive( TEndResult ER ) {}
      
      //Уведомление в том что запись закончилась
      //ER - Код завершения
      //Разрыв соединения и вызов OnDisconnect может пройти и без вызова OnEndSend
      void OnEndSend( TEndResult ER ) {}
      
      //Уведомление в том что сработал таймер ожидания операции чтения или записи
      //Можно вызвать TryDisconnect, для завершения соединения или выполнить другие действия,
      //например попытаться отправить запрос KEEP ALIVE (если не было ожидания операции записи)
      void OnTimer() {}

      //Уведомление в том что сработал таймер ожидания подключения к серверу
      //Можно вызвать TryDisconnect, для завершения попыток подключения или выполнить другие действия
      void OnConnectTimer() {}

      //Деструктор объекта вызывается сразу после того как соединение разорвано
      ~TConnectionBasic() {}
   };
} //namespace AsyncIOConnection 
} //namespace NWLib

#endif